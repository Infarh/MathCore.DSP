# Фазовая демодуляция для SampleSI16

## Описание

Реализован высокопроизводительный алгоритм фазовой демодуляции радиосигнала для квадратурных отсчетов типа `SampleSI16`. Алгоритм предназначен для использования в системах реального времени.

## Алгоритм

### Входные параметры
- `samples` - последовательность квадратурных отсчетов (I/Q) типа `SampleSI16`
- `f0` - центральная частота фазовой модуляции (Гц)
- `fd` - частота дискретизации (Гц)

### Выходные данные
- Массив `float[]` с демодулированными значениями мгновенной частоты (Гц)

### Основные этапы

1. **Вычисление фазы** - для каждого квадратурного отсчета вычисляется фаза с помощью `atan2(Q, I)`

2. **Разворачивание фазы (Phase Unwrapping)** - устранение скачков ±2π для получения непрерывной фазы

3. **Вычисление мгновенной частоты** - как производная фазы по времени:
   ```
   instantaneous_frequency = (phase[i] - phase[i-1]) * fd / (2π)
   ```

4. **Вычитание центральной частоты** - для получения демодулированного сигнала:
   ```
   result[i] = instantaneous_frequency - f0
   ```

## Оптимизации

- Использование `MethodImpl(MethodImplOptions.AggressiveInlining)` для критических функций
- Минимизация выделения памяти (только один выделенный массив для результата и временный массив фаз)
- Использование оптимизированных функций `SampleSI16.GetArg()` для вычисления фазы
- Эффективный алгоритм unwrapping фазы с линейной сложностью O(n)

## Производительность

Алгоритм обрабатывает 100 000 образцов за время менее 200 мс на современном оборудовании, что обеспечивает работу в режиме реального времени.

## Пример использования

```csharp
using MathCore.DSP.Samples;
using MathCore.DSP.Samples.Extensions;

// Создаем массив квадратурных отсчетов
var samples = new SampleSI16[]
{
    new(100, 0),   // I=100, Q=0
    new(71, 71),   // I=71, Q=71
    // ... другие отсчеты
};

// Параметры демодуляции
const double f0 = 1000.0;  // Центральная частота 1 кГц
const double fd = 48000.0; // Частота дискретизации 48 кГц

// Выполняем фазовую демодуляцию
var demodulated = samples.AsSpan().PhaseDemodulation(f0, fd);

// demodulated[0] всегда равен 0
// demodulated[1..] содержат мгновенные частоты в Гц
```

## Ограничения

- Первый элемент результирующего массива всегда равен 0, так как для вычисления производной требуется предыдущий отсчет
- Точность демодуляции зависит от отношения сигнал/шум входных данных
- Алгоритм предполагает, что входной сигнал имеет достаточную амплитуду для корректного вычисления фазы