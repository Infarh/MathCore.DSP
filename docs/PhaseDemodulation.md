# Фазовая демодуляция и модуляция для SampleSI16

## Описание

Реализованы высокопроизводительные алгоритмы фазовой демодуляции и модуляции для квадратурных отсчетов типа `SampleSI16`. Алгоритмы предназначены для использования в системах реального времени с критичными требованиями к производительности.

## Фазовая демодуляция

### Ключевые оптимизации демодуляции

1. **Прямое вычисление разности фаз через комплексное произведение**
2. **Уменьшение вызовов `atan2` в 2 раза**
3. **Устранение промежуточного массива фаз**
4. **Упрощенный unwrapping с накоплением коррекции**

### Алгоритм демодуляции

```csharp
public static float[] PhaseDemodulation(this Span<SampleSI16> samples, double f0, double fd)
```

#### Входные параметры
- `samples` - последовательность квадратурных отсчетов (I/Q) типа `SampleSI16`
- `f0` - центральная частота фазовой модуляции (Гц)
- `fd` - частота дискретизации (Гц)

#### Выходные данные
- Массив `float[]` с демодулированными значениями мгновенной частоты (Гц)

## Фазовая модуляция

### Алгоритмы модуляции

#### 1. Базовая модуляция
```csharp
public static SampleSI16[] PhaseModulation(this ReadOnlySpan<float> data, double f0, double fd, float amplitude = 120f)
```

#### 2. Модуляция с управляемой начальной фазой
```csharp
public static (SampleSI16[] samples, double final_phase) PhaseModulation(
    this ReadOnlySpan<float> data, double f0, double fd, double initial_phase, float amplitude = 120f)
```

### Входные параметры модуляции
- `data` - модулирующие данные (отклонения частоты от центральной в Гц)
- `f0` - центральная частота передачи (Гц)
- `fd` - частота дискретизации (Гц)
- `amplitude` - амплитуда выходного сигнала (по умолчанию 120 для оптимального использования динамического диапазона)
- `initial_phase` - начальная фаза для обеспечения непрерывности между блоками

### Выходные данные модуляции
- Массив `SampleSI16[]` с квадратурными отсчетами для передачи
- `final_phase` - финальная фаза для продолжения в следующем блоке

## Алгоритм модуляции

### Основные этапы

1. **Интегрирование мгновенной частоты**:
   ```
   instantaneous_frequency = f0 + data[i]
   ω(t) = 2π × instantaneous_frequency
   φ(t) = ∫ω(t)dt = φ(t-1) + ω(t) × dt
   ```

2. **Генерация квадратурного сигнала**:
   ```
   I = amplitude × cos(φ(t))
   Q = amplitude × sin(φ(t))
   ```

3. **Ограничение в диапазоне sbyte**:
   ```
   I_sample = clamp(I, -127, 127)
   Q_sample = clamp(Q, -127, 127)
   ```

## Производительность

### Результаты тестирования

#### Демодуляция
- **1 млн образцов**: ~200-250 мс
- **Производительность**: ~4-5 млн образцов/сек
- **Ускорение**: ~2x по сравнению с наивной реализацией

#### Модуляция
- **1 млн образцов**: ~50-100 мс
- **Производительность**: ~10-20 млн образцов/сек

### Совместимость
- .NET 9.0: использует `MathF` функции
- .NET 8.0: использует `MathF` функции
- .NET Standard 2.0: использует `Math` функции с приведением к `float`

## Круговое преобразование (Round-trip)

Алгоритмы демодуляции и модуляции взаимно обратны:

```csharp
// Исходные данные
var original_data = new float[] { 0f, 100f, -200f, 300f };

// Модуляция
var modulated = original_data.AsSpan().PhaseModulation(f0, fd);

// Демодуляция
var demodulated = modulated.AsSpan().PhaseDemodulation(f0, fd);

// demodulated ≈ original_data (с точностью до переходных процессов)
```

## Примеры использования

### Демодуляция принятого сигнала
```csharp
using MathCore.DSP.Samples;
using MathCore.DSP.Samples.Extensions;

// Квадратурные отсчеты от приемника
var received_samples = new SampleSI16[]
{
    new(100, 0), new(71, 71), new(0, 100), // ... 
};

const double f0 = 2400.0;  // Центральная частота 2.4 ГГц
const double fd = 48000.0; // 48 кГц дискретизация

// Демодуляция
var demodulated_data = received_samples.AsSpan().PhaseDemodulation(f0, fd);
```

### Модуляция для передачи
```csharp
// Данные для передачи (отклонения частоты в Гц)
var transmit_data = new float[] 
{ 
    0f,     // Центральная частота
    500f,   // +500 Гц 
    -300f,  // -300 Гц
    100f    // +100 Гц
};

const double f0 = 915000000.0; // 915 МГц ISM диапазон
const double fd = 2000000.0;   // 2 МГц дискретизация

// Модуляция
var iq_samples = transmit_data.AsSpan().PhaseModulation(f0, fd, amplitude: 120f);

// Отправка в буфер передатчика
SendToTransmitter(iq_samples);
```

### Непрерывная модуляция блоками
```csharp
var phase = 0.0; // Начальная фаза

foreach (var data_block in data_blocks)
{
    var (samples, final_phase) = data_block.PhaseModulation(f0, fd, phase);
    
    // Отправляем блок
    TransmitBlock(samples);
    
    // Продолжаем с сохранением фазы
    phase = final_phase;
}
```

## Ограничения

### Демодуляция
- Первый элемент результирующего массива всегда равен 0
- Точность зависит от отношения сигнал/шум
- Требуется достаточная амплитуда для корректного вычисления фазы

### Модуляция
- Ограничение амплитуды диапазоном [-127, +127]
- Квантование может вносить дополнительные гармоники
- При очень высоких девиациях частоты возможны артефакты

## Математическое обоснование

### Демодуляция
Разность фаз двух комплексных чисел:
```
Δφ = arg(z₁) - arg(z₂) = arg(z₁ × z₂*)
z₁ × z₂* = (I₁I₂ + Q₁Q₂) + j(Q₁I₂ - I₁Q₂)
```

### Модуляция
Интегрирование мгновенной частоты:
```
φ(t) = ∫[0→t] 2π × f(τ) dτ
f(t) = f₀ + Δf(t)
```

Генерация квадратурного сигнала:
```
s(t) = A × e^(jφ(t)) = A × [cos(φ(t)) + j×sin(φ(t))]
I(t) = A × cos(φ(t))
Q(t) = A × sin(φ(t))