# MathCore.DSP

Библиотека цифровой обработки сигналов (Digital Signal Processing) для .NET, предоставляющая набор базовых и продвинутых алгоритмов анализа и преобразования дискретных сигналов.

## Кратко
- Быстрые преобразования Фурье (FFT/Inverse FFT)
- Свёртка, корреляция, авто/взаимо‑корреляция
- Оконные функции (Hann, Hamming, Blackman, Kaiser и др.)
- Проектирование FIR/IIR‑фильтров (низкочастотные, высокочастотные, полосовые, режекторные)
- Дискретизация, ресэмплинг, интерполяция
- Спектральный анализ, оценка амплитудного/фазового спектров
- Нормализация, сглаживание, выделение огибающей
- Работа с комплексными сигналами (структуры, операции)
- Вспомогательные численные методы и утилиты

## Целевые платформы
| TFM | Версия | Назначение |
|-----|--------|-----------|
| netstandard2.0 | .NET Standard 2.0 | Совместимость с широким спектром ранних платформ |
| net8.0 | .NET 8 | Современные приложения |
| net9.0 | .NET 9 | Актуальные возможности и оптимизации |
| net10.0 | .NET 10 | Самая свежая платформа |

## Установка
```bash
# Установка через NuGet
 dotnet add package MathCore.DSP
```

## Пример: расчёт спектра и фильтрация
```csharp
using MathCore.DSP;              // Основные типы
using MathCore.DSP.FFT;          // FFT‑алгоритмы
using MathCore.DSP.Filters;      // Фильтры
using MathCore.DSP.Windows;      // Оконные функции

// Допустим есть сигнал
double[] signal = GetInputSamples(); // Получаем массив выборок (пользовательский метод) // получаем данные
int n = signal.Length;               // Длина сигнала // сохраняем длину

// Применим окно Хэнна для снижения утечек спектра
var window = Window.Hann(n);         // Генерируем окно Хэнна // создаём окно
for (var i = 0; i < n; i++)          // Применяем окно к сигналу // применяем окно
    signal[i] *= window[i];          // Умножаем на окно // масштабируем

// Выполним прямое FFT
var spectrum = FFT.RealFFT(signal);  // Расчёт комплексного спектра // считаем спектр

// Получим амплитудный спектр
var amplitudes = spectrum.GetAmplitudes(); // Амплитуды гармоник // извлекаем амплитуды

// Спроектируем низкочастотный FIR‑фильтр
double sampleRate = 48000;           // Частота дискретизации Гц // задаём частоту
double cutoff = 5000;                // Частота среза Гц // задаём срез
int order = 127;                     // Порядок фильтра (количество коэффициентов - 1) // задаём порядок
var fir = FirFilter.LowPass(order, cutoff, sampleRate, WindowType.Blackman); // Создаём фильтр // проектируем FIR

// Применим фильтр к исходному сигналу
var filtered = fir.Process(signal);  // Фильтрация // применяем фильтр

// Обратное FFT для восстановления (пример для модифицированного спектра)
var restored = FFT.RealInverseFFT(spectrum, n); // Обратное преобразование // обратное FFT
```

## Возможности фильтров
- FIR: прямое проектирование через оконные функции, поддержка разных типов окон
- IIR: би-квадратичные секции (Biquad), стандартные прототипы (Butterworth и др.)
- Поддержка пакетной обработки и потоковой фильтрации (Stateful)

## Производительность
- Используются оптимизированные реализации FFT (итеративные алгоритмы разбиения по битам)
- Минимизация аллокаций за счёт переиспользования буферов там, где это возможно
- Возможна интеграция с `Span<T>` и `Memory<T>` (на поддерживаемых TFM)

## Структура
- `MathCore.DSP.FFT` – преобразования Фурье
- `MathCore.DSP.Filters` – фильтры и проектирование
- `MathCore.DSP.Windows` – оконные функции
- `MathCore.DSP.Signals` – типы данных сигналов
- `MathCore.DSP.Statistics` – статистический анализ

## Пример: свёртка двух сигналов
```csharp
using MathCore.DSP.Operations; // Предположим модуль операций

double[] a = { 1, 2, 3, 4 };          // Первый сигнал // данные A
double[] b = { 0.25, 0.5, 0.25 };     // Импульсная характеристика фильтра // данные B

var convolution = Convolution.Linear(a, b); // Линейная свёртка // выполняем свёртку
```

## Лицензия
MIT. Свободное использование в коммерческих и открытых проектах с сохранением уведомления о лицензии.

## Обратная связь
- Issues: создавайте задачи на GitHub для багов и предложений
- Discussions: предлагайте идеи и задавайте вопросы

## Минимальный пример
```csharp
// Быстрый расчёт амплитудного спектра
var amplitudes = FFT.RealFFT(samples).GetAmplitudes(); // Получаем массив амплитуд
```

## Примечания
- API может эволюционировать между основными версиями
- При использовании в реальном времени уделяйте внимание задержкам фильтров FIR (линейная фаза -> групповая задержка = (N-1)/2)

## Начало работы
1. Установите пакет
2. Добавьте `using MathCore.DSP;`
3. Выберите окно (если требуется) и выполните FFT или фильтрацию
4. Анализируйте спектр, модифицируйте сигнал, применяйте преобразования

---
Если нужна дополнительная функциональность – создайте Issue: это помогает развивать библиотеку.
