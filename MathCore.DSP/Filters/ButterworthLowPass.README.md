# ButterworthLowPass — Низкочастотный фильтр Баттерворта

## Обзор

`ButterworthLowPass` — это реализация цифрового низкочастотного фильтра Баттерворта на основе аналогового прототипа. Фильтр обеспечивает максимально плоскую амплитудную характеристику в полосе пропускания и используется для подавления высокочастотных шумов и нежелательных сигналов.

**Пространство имен**: `MathCore.DSP.Filters`  
**Базовый класс**: `ButterworthFilter`  
**Интерфейсы**: Наследует интерфейсы из `IIR` и `DigitalFilter`

---

## Основные возможности

- ✅ **Расчет порядка фильтра** — автоматический расчет минимального порядка для выполнения спецификации
- ✅ **Синтез коэффициентов** — вычисление коэффициентов передаточной функции (числитель и знаменатель)
- ✅ **Гибкие параметры** — поддержка произвольных частот дискретизации и граничных частот
- ✅ **Контроль затухания** — настраиваемое затухание в полосе пропускания и заграждения
- ✅ **Точная трансформация** — билинейное преобразование для преобразования полюсов из s-плоскости в z-плоскость
- ✅ **Простой интерфейс** — удобные конструкторы с разумными значениями по умолчанию
- ✅ **Полная документация** — XML-документация для intellisense и встроенные примеры

---

## Архитектура

### Иерархия классов

```
DigitalFilter (базовый класс для цифровых фильтров)
    ↓
IIR (бесконечная импульсная характеристика)
    ↓
AnalogBasedFilter (фильтры на основе аналоговых прототипов)
    ↓
ButterworthFilter (абстрактный класс Баттерворта)
    ↓
ButterworthLowPass ← ФНЧ (этот класс)
ButterworthHighPass ← ФВЧ
ButterworthBandPass ← ППФ
ButterworthBandStop ← ПЗФ
```

### Основные компоненты

| Компонент | Тип | Описание |
|-----------|-----|---------|
| `ButterworthLowPass` | Класс | Публичный класс фильтра ФНЧ с методами синтеза и конструкторами |
| `Specification` | Структура | Параметры спецификации фильтра (dt, fp, fs, Gp, Gs) |
| `GetNormPoles()` | Метод | Расчет нормированных полюсов в s-плоскости (наследуется от ButterworthFilter) |
| `TransformToLowPassW()` | Метод | Преобразование полюсов на требуемую циклическую частоту пропускания |
| `ToZArray()` | Метод | Билинейное преобразование (s-плоскость → z-плоскость) |
| `GetCoefficientsInverted()` | Метод | Расчет коэффициентов полиномов из полюсов |

### Процесс синтеза фильтра

```
┌─────────────────────────────────────────────────┐
│      Входные параметры                          │
│  (dt, fp, fs, Gp=0.891250938, Gs=0.01)        │
└────────────────────┬────────────────────────────┘
                     ↓
         ┌──────────────────────┐
         │  Валидация параметров│
         │  (в конструкторе)    │
         └──────────┬───────────┘
                    ↓
        ┌───────────────────────┐
        │  GetPolynoms()        │
        └────────┬──────────────┘
                 ↓
    ┌────────────────────────────────┐
    │ 1. GetOrder() / GetNormPoles() │
    │    Вычисления порядка N        │
    │    и нормированных полюсов     │
    └────────────┬───────────────────┘
                 ↓
    ┌────────────────────────────────┐
    │ 2. TransformToLowPassW()        │
    │    Трансформация полюсов на    │
    │    требуемую частоту wp        │
    └────────────┬───────────────────┘
                 ↓
    ┌────────────────────────────────┐
    │ 3. ToZArray()                  │
    │    Билинейное преобразование   │
    │    (s-плоскость → z-плоскость) │
    │    Используется: z = (1+s*dt/2)│
    │                  /(1-s*dt/2)   │
    └────────────┬───────────────────┘
                 ↓
    ┌────────────────────────────────┐
    │ 4. Расчет нормирующего         │
    │    коэффициента g_norm         │
    │    g_norm = ∏(1-zk)/2          │
    └────────────┬───────────────────┘
                 ↓
    ┌────────────────────────────────┐
    │ 5. Формирование коэффициентов │
    │    B[i] = g_norm * C(N,i)     │
    │    A[*] = обратные коэффиценты│
    └────────────┬───────────────────┘
                 ↓
         ┌──────────────────────┐
         │  (A[], B[])          │
         │  Коэффициенты        │
         │  передаточной функции│
         └──────────┬───────────┘
                    ↓
         ┌──────────────────────┐
         │ AnalogBasedFilter    │
         │ Инициализация        │
         │ базового класса      │
         └──────────┬───────────┘
                    ↓
         ┌──────────────────────┐
         │ Готовый фильтр       │
         │ filter.Process(x)    │
         └──────────────────────┘
```

---

## Примеры использования

### Пример 1: Создание простого фильтра с параметрами по умолчанию

```csharp
using MathCore.DSP.Filters;

// Параметры дискретизации
double dt = 0.001;  // Период дискретизации (частота 1000 Гц)

// Граничные частоты
double fp = 100;    // Граница пропускания: 100 Гц
double fs = 200;    // Граница заграждения: 200 Гц

// Создание фильтра с затуханием по умолчанию
// Gp = 0.891250938 (-1 дБ в полосе пропускания)
// Gs = 0.01 (-40 дБ в полосе заграждения)
var filter = new ButterworthLowPass(dt, fp, fs);

// Фильтрование единичного отсчета
double output = filter.Process(1.0);
Console.WriteLine($"Выход: {output:F6}");
```

### Пример 2: Создание фильтра с пользовательскими параметрами затухания

```csharp
// Более строгие требования к затуханию
double Gp = 0.9441 /  // -0.5 дБ в полосе пропускания
double Gs = 0.001;    // -60 дБ в полосе заграждения

var filterStrict = new ButterworthLowPass(
    dt: 0.001,
    fp: 100,
    fs: 200,
    Gp: Gp,
    Gs: Gs
);

// Этот фильтр будет иметь более высокий порядок для выполнения более строгих требований
```

### Пример 3: Расчет параметров фильтра

```csharp
// Определение требуемого порядка фильтра
int order = ButterworthLowPass.GetOrder(
    dt: 0.001,
    fp: 100,
    fs: 200,
    Gp: 0.891250938,  // -1 дБ
    Gs: 0.01          // -40 дБ
);
Console.WriteLine($"Требуемый порядок: {order}");

// Определение частоты заграждения для известного порядка
double fsCalc = ButterworthLowPass.GetFrequencyStop(
    dt: 0.001,
    fp: 100,
    Order: order
);
Console.WriteLine($"Рассчитанная частота заграждения: {fsCalc:F2} Гц");

// Обратный расчет: определить частоту пропускания
double fpCalc = ButterworthLowPass.GetFrequencyPass(
    dt: 0.001,
    Order: order,
    fs: 200
);
Console.WriteLine($"Рассчитанная частота пропускания: {fpCalc:F2} Гц");
```

### Пример 4: Получение полюсов фильтра

```csharp
// Получение полюсов для анализа (в s-плоскости нормированные)
var poles = ButterworthLowPass.GetPoles(Order: 4).ToList();

Console.WriteLine($"Количество полюсов: {poles.Count}");
foreach (var pole in poles)
{
    Console.WriteLine($"Полюс: {pole.Real:F6} + j{pole.Imaginary:F6}");
}

// Вывод для порядка 4:
// Полюс: -0.270240 + j0.655537
// Полюс: -0.270240 - j0.655537
// Полюс: -0.655537 + j0.270240
// Полюс: -0.655537 - j0.270240
```

### Пример 5: Получение коэффициентов передаточной функции

```csharp
// Создание спецификации
var spec = new AnalogBasedFilter.Specification(
    dt: 0.001,
    fp: 100,
    fs: 200,
    Gp: 0.891250938,
    Gs: 0.01
);

// Получение коэффициентов
var (A, B) = ButterworthLowPass.GetPolynoms(spec);

Console.WriteLine($"Порядок фильтра: {A.Length - 1}");
Console.WriteLine("Коэффициенты числителя (B):");
for (int i = 0; i < B.Length; i++)
    Console.WriteLine($"  B[{i}] = {B[i]:E6}");

Console.WriteLine("Коэффициенты знаменателя (A):");
for (int i = 0; i < A.Length; i++)
    Console.WriteLine($"  A[{i}] = {A[i]:E6}");

// Пример результата для 4-го порядка:
// Коэффициенты числителя (B):
//   B[0] = 2.500000E-06
//   B[1] = 1.000000E-05
//   B[2] = 1.500000E-05
//   B[3] = 1.000000E-05
//   B[4] = 2.500000E-06
// Коэффициенты знаменателя (A):
//   A[0] = 1.000000E+00
//   A[1] = -3.991900E+00
//   ...
```

### Пример 6: Обработка сигнала в реальном времени

```csharp
// Создание фильтра
var filter = new ButterworthLowPass(
    dt: 0.001,      // 1000 Гц
    fp: 50,         // Граница пропускания
    fs: 100         // Граница заграждения
);

// Входной сигнал с шумом (например, с датчика)
double[] inputSignal = new double[] 
{ 
    1.2, 1.5, 2.1, 1.8, 0.9, 1.1, 2.3, 2.0, 1.5, 0.8 
};

// Фильтрование сигнала (сохранение состояния между отсчетами)
double[] filteredSignal = new double[inputSignal.Length];
for (int i = 0; i < inputSignal.Length; i++)
{
    filteredSignal[i] = filter.Process(inputSignal[i]);
}

// Вывод результатов
Console.WriteLine("Отсчет | Вход  | Выход");
Console.WriteLine("-------|-------|--------");
for (int i = 0; i < filteredSignal.Length; i++)
{
    Console.WriteLine($"{i,5:D} | {inputSignal[i],5:F2} | {filteredSignal[i],6:F4}");
}
```

### Пример 7: Обработка цифрового потока

```csharp
using System;
using System.Linq;
using MathCore.DSP.Filters;

// Создание фильтра из спецификации
var spec = new AnalogBasedFilter.Specification(
    dt: 0.001,
    fp: 10,
    fs: 20,
    Gp: 0.891250938,
    Gs: 0.01
);

var filter = new ButterworthLowPass(spec);

// Генерирование тестового сигнала (синус + высокочастотный шум)
double[] signal = Enumerable
    .Range(0, 1000)
    .Select(i => 
    {
        double t = i * 0.001;
        double sine = Math.Sin(2 * Math.PI * 5 * t);      // 5 Гц синус
        double noise = Math.Sin(2 * Math.PI * 50 * t) * 0.3; // 50 Гц "шум"
        return sine + noise;
    })
    .ToArray();

// Фильтрование
double[] filtered = signal.Select(filter.Process).ToArray();

// Вывод статистики
Console.WriteLine($"Исходный сигнал: мин={signal.Min():F3}, макс={signal.Max():F3}");
Console.WriteLine($"Отфильтрованный: мин={filtered.Min():F3}, макс={filtered.Max():F3}");
Console.WriteLine($"Фильтр подавил высокочастотный шум!");
```

---

## API Документация

### Статические методы

#### `GetOrder(double dt, double fp, double fs, double Gp = 0.891250938, double Gs = 0.01) → int`

Вычисляет минимальный порядок фильтра для выполнения спецификации.

**Параметры:**
- `dt` *(double)* — период дискретизации (сек). Обычно 1/fd где fd — частота дискретизации
- `fp` *(double)* — граничная частота полосы пропускания (Гц). Сигналы ниже этой частоты должны пройти
- `fs` *(double)* — граничная частота полосы заграждения (Гц). Сигналы выше этой частоты должны быть подавлены
- `Gp` *(double)* — коэффициент передачи в полосе пропускания, диапазон (0, 1]. По умолчанию 0.891250938 эквивалентно -1 дБ
- `Gs` *(double)* — коэффициент передачи в полосе заграждения, диапазон (0, 1). По умолчанию 0.01 эквивалентно -40 дБ

**Возвращает:** *(int)* Минимальный порядок фильтра (≥1)

**Примечание:** Результат округляется в большую сторону для гарантии выполнения требований.

---

#### `GetFrequencyStop(double dt, double fp, int Order, double Gp = 0.891250938, double Gs = 0.01) → double`

Определяет граничную частоту заграждения по известному порядку фильтра.

**Параметры:**
- `dt` *(double)* — период дискретизации (сек)
- `fp` *(double)* — граничная частота пропускания (Гц)
- `Order` *(int)* — порядок фильтра (обычно получается из GetOrder)
- `Gp` *(double)* — коэффициент передачи в полосе пропускания (по умолч. 0.891250938)
- `Gs` *(double)* — коэффициент передачи в полосе заграждения (по умолч. 0.01)

**Возвращает:** *(double)* Граничная частота заграждения (Гц)

**Используется для:** Обратного расчета спецификации, когда знаем порядок и хотим узнать fs.

---

#### `GetFrequencyPass(double dt, int Order, double fs, double Gp = 0.891250938, double Gs = 0.01) → double`

Определяет граничную частоту пропускания по известному порядку фильтра.

**Параметры:**
- `dt` *(double)* — период дискретизации (сек)
- `Order` *(int)* — порядок фильтра
- `fs` *(double)* — граничная частота заграждения (Гц)
- `Gp` *(double)* — коэффициент передачи в полосе пропускания (по умолч. 0.891250938)
- `Gs` *(double)* — коэффициент передачи в полосе заграждения (по умолч. 0.01)

**Возвращает:** *(double)* Граничная частота пропускания (Гц)

**Используется для:** Определения fp, когда известны Order и fs.

---

#### `GetPoles(int Order, double Gp = 0.891250938) → IEnumerable<Complex>`

Получает нормированные полюса фильтра Баттерворта в s-плоскости.

**Параметры:**
- `Order` *(int)* — порядок фильтра (количество полюсов)
- `Gp` *(double)* — коэффициент передачи (по умолч. 0.891250938)

**Возвращает:** *(IEnumerable&lt;Complex&gt;)* Перечисление комплексных полюсов

**Примечание:** 
- Полюса нормированы на частоту 1 рад/с
- Для четного порядка все полюса комплексные и образуют сопряженные пары
- Для нечетного порядка есть один действительный полюс

---

#### `GetPolynoms(Specification Spec) → (double[] A, double[] B)`

Вычисляет коэффициенты передаточной функции H(z) = B(z)/A(z).

**Параметры:**
- `Spec` *(Specification)* — структура со всеми параметрами фильтра

**Возвращает:** *((double[], double[]))* Кортеж:
  - **A[]** — коэффициенты полинома знаменателя. Обычно A[0] = 1.0
  - **B[]** — коэффициенты полинома числителя

**Этапы вычисления:**
1. Расчет порядка N из спецификации
2. Получение нормированных полюсов
3. Трансформация на требуемую частоту Wp
4. Билинейное преобразование в z-плоскость
5. Расчет нормирующего коэффициента
6. Формирование коэффициентов

**Используется:** Внутри конструкторов для инициализации базового класса.

---

### Конструкторы

#### `ButterworthLowPass(double dt, double fp, double fs, double Gp = 0.891250938, double Gs = 0.01)`

Создает фильтр с указанными параметрами частотной характеристики.

**Параметры:**
- `dt` *(double)* — период дискретизации (сек). Обычно 1/fd
- `fp` *(double)* — граничная частота полосы пропускания (Гц). Должна быть < fd/2
- `fs` *(double)* — граничная частота полосы заграждения (Гц). Должна быть > fp
- `Gp` *(double)* — коэффициент передачи в полосе пропускания (по умолч. 0.891250938 = -1 дБ)
- `Gs` *(double)* — коэффициент передачи в полосе заграждения (по умолч. 0.01 = -40 дБ)

**Исключения:**
- `InvalidOperationException` — если условие fp ≥ половины частоты дискретизации или Gp ≤ Gs
- `ArgumentOutOfRangeException` — если параметры выходят за допустимые границы

**Примечание:** Конструктор автоматически вызывает GetPolynoms и инициализирует базовый класс.

---

#### `ButterworthLowPass(Specification Spec)`

Создает фильтр из спецификации.

**Параметры:**
- `Spec` *(Specification)* — структура со всеми параметрами (dt, fp, fs, Gp, Gs)

**Используется для:** Переиспользования спецификации или сохранения параметров.

---

### Унаследованные методы

Из класса `DigitalFilter` / `IIR`:

```csharp
// Основной метод фильтрования
double Process(double x);

// Получение частотной характеристики
Complex FrequencyResponse(double f);

// Сброс состояния фильтра
void Reset();
```

---

## Спецификация фильтра (Specification)

### Свойства

| Свойство | Тип | Описание |
|----------|-----|---------|
| `dt` | double | Период дискретизации (сек). Обратное значение частоте дискретизации |
| `fd` | double | Частота дискретизации (Гц) = 1/dt |
| `fp` | double | Граничная частота пропускания (Гц) |
| `fs` | double | Граничная частота заграждения (Гц) |
| `Gp` | double | Коэффициент передачи в полосе пропускания [0, 1] |
| `Gs` | double | Коэффициент передачи в полосе заграждения [0, 1] |
| `wp` | double | Циклическая частота пропускания = 2π·fp |
| `ws` | double | Циклическая частота заграждения = 2π·fs |
| `EpsP` | double | Неоднородность АЧХ в полосе пропускания = √(1/Gp² - 1) |
| `EpsS` | double | Неоднородность АЧХ в полосе заграждения = √(1/Gs² - 1) |
| `kEps` | double | Отношение неоднородностей = EpsS / EpsP |
| `kW` | double | Отношение циклических частот = Ws / Wp |

### Значения по умолчанию

```
Gp = 0.891250938  ≈ 10^(-1/20) = -1 дБ
Gs = 0.01         ≈ 10^(-40/20) = -40 дБ
```

Эти значения обеспечивают:
- Умеренное ослабление сигнала в полосе пропускания (почти незаметное)
- Сильное подавление в полосе заграждения
- Хороший компромисс между порядком фильтра и перекрытием полос

---

## Математическое описание

### Порядок фильтра Баттерворта

Минимальный порядок вычисляется по формуле:

```
        0.5 × log(kε²)
N = ⌈─────────────────⌉
        log(kω)
```

где:
```
kε² = (1/Gs² - 1) / (1/Gp² - 1)
kω  = ωs / ωp = tan(π·fs·dt) / tan(π·fp·dt)
```

Это гарантирует, что фильтр порядка N выполнит требования спецификации.

### Полюса нормированного фильтра

Полюса фильтра Баттерворта в s-плоскости расположены на окружности радиуса α:

```
sk = α · exp(j·π·(2k+N+1)/(2N)),  k = 0,1,...,N-1
```

где:
```
α = ε^(-1/N)
ε = √(1/Gp² - 1)
```

### Билинейное преобразование

Преобразование из s-плоскости в z-плоскость:

```
        z - 1
s = (2/dt)────
        z + 1
```

Обратное преобразование:

```
      1 + s·dt/2
z = ───────────
      1 - s·dt/2
```

Это сохраняет устойчивость фильтра (полюса внутри единичной окружности).

### Передаточная функция

Цифровой фильтр реализует:

```
     b₀ + b₁·z⁻¹ + b₂·z⁻² + ... + bₙ·z⁻ⁿ
H(z) = ──────────────────────────────────────
     a₀ + a₁·z⁻¹ + a₂·z⁻² + ... + aₙ·z⁻ⁿ
```

Обычно нормировано так, что a₀ = 1.

---

## Точки расширения

### Использование в других фильтрах

`ButterworthLowPass` может использоваться как основа для:

```csharp
// 1. Прямое использование для низкочастотной фильтрации
var lowpass = new ButterworthLowPass(dt, 100, 200);

// 2. Комбинирование с другими фильтрами (например, высокочастотный):
// Можно применить преобразование спектра для получения ФВЧ или ППФ
```

### Наследование

Для создания специализированного фильтра:

```csharp
public class AdaptiveButterworthFilter : ButterworthLowPass
{
    private double _adaptiveGp = 0.891250938;
    
    public AdaptiveButterworthFilter(double dt, double fp, double fs)
        : base(dt, fp, fs)
    {
    }
    
    public void AdjustGain(double newGp)
    {
        _adaptiveGp = newGp;
        // Пересоздать фильтр с новыми параметрами
    }
}
```

### Использование с другими типами сигналов

```csharp
// 1. Трехмерный вектор (например, акселерометр)
var filter = new ButterworthLowPass(0.001, 10, 20);
var vector = new Vector3(1.2f, 1.5f, 0.8f);
var filtered = new Vector3(
    filter.Process(vector.X),
    filter.Process(vector.Y),
    filter.Process(vector.Z)
);

// 2. Отдельные экземпляры для разных каналов
var filterX = new ButterworthLowPass(0.001, 10, 20);
var filterY = new ButterworthLowPass(0.001, 10, 20);
var filterZ = new ButterworthLowPass(0.001, 10, 20);
```

---

## Производительность

### Рекомендации по оптимизации

1. **Переиспользование фильтра** — Создавайте фильтр один раз в инициализации:
   ```csharp
   // ✅ Хорошо: фильтр создан один раз
   var filter = new ButterworthLowPass(dt, fp, fs);
   foreach (var sample in samples)
       output = filter.Process(sample);  // Быстро, O(N) на отсчет
   
   // ❌ Плохо: фильтр создается каждый раз
   foreach (var sample in samples)
   {
       var filter = new ButterworthLowPass(dt, fp, fs);  // Дорого! O(N³)
       output = filter.Process(sample);
   }
   ```

2. **Выбор порядка фильтра** — Используйте минимально необходимый порядок:
   ```csharp
   // Рекомендация: вычислить требуемый порядок
   int minOrder = ButterworthLowPass.GetOrder(dt, fp, fs);
   // Порядок выше → больше вычислений, но лучше подавление
   // Порядок ниже → меньше вычислений, но хуже подавление
   ```

3. **Параллельная обработка** — Используйте отдельные экземпляры для разных потоков:
   ```csharp
   var filterPerThread = new ButterworthLowPass(dt, fp, fs);
   Parallel.ForEach(samples, sample =>
   {
       var output = filterPerThread.Process(sample);
   });
   ```

4. **Батч-обработка** — Обработайте блоки сэмплов:
   ```csharp
   var output = new double[batchSize];
   for (int i = 0; i < batchSize; i++)
       output[i] = filter.Process(input[i]);
   ```

### Сложность по памяти и времени

| Операция | Сложность | Примечания |
|----------|-----------|-----------|
| Конструктор | O(N³) | N — порядок фильтра. Выполняется один раз при инициализации |
| `Process()` | O(N) | Свертка на каждый отсчет. Критична в реал-времени |
| `GetOrder()` | O(1) | Только логарифмические вычисления |
| `GetPolynoms()` | O(N²) | Расчет полюсов и коэффициентов |
| Память | O(N) | Хранение состояния и коэффициентов |

### Рекомендуемые порядки

| Приложение | Типичный порядок | Затухание |
|-----------|------------------|-----------|
| Сглаживание шума датчика | 2-4 | 20-40 дБ |
| Аудио (CD качество) | 6-8 | 40-60 дБ |
| Профессиональная обработка | 8-12 | 60-120 дБ |
| Научные измерения | 10-16 | 80-160 дБ |

---

## Обработка ошибок

### Исключения при создании

```csharp
try
{
    var filter = new ButterworthLowPass(dt: 0.001, fp: 600, fs: 800);
}
catch (InvalidOperationException ex)
{
    // Проверить:
    // 1. fp < fd/2 (т.е. fp < 500 при fd=1000)
    // 2. Gp > Gs
    Console.WriteLine($"Ошибка спецификации: {ex.Message}");
}
catch (ArgumentOutOfRangeException ex)
{
    // Проверить диапазоны:
    // 0 < Gp <= 1
    // 0 < Gs < 1
    Console.WriteLine($"Параметр '{ex.ParamName}' вне диапазона");
}
```

### Валидация параметров

| Условие | Результат | Действие |
|---------|-----------|---------|
| `fp >= fd/2` | ❌ Ошибка | fp должна быть < Найквист-частота (fd/2) |
| `fs <= fp` | ❌ Ошибка | fs должна быть > fp |
| `Gp <= Gs` | ❌ Ошибка | Затухание пропускания должно быть > затухания заграждения |
| `Gp` или `Gs` ≤ 0 | ❌ Ошибка | Коэффициент передачи должен быть положительным |
| `Gp` > 1 | ❌ Ошибка | Коэффициент передачи не может быть > 1 |
| `dt` ≤ 0 | ❌ Ошибка | Период должен быть положительным |

### Обработка исключений в коде

```csharp
public static ButterworthLowPass CreateSafeFilter(double dt, double fp, double fs)
{
    try
    {
        return new ButterworthLowPass(dt, fp, fs);
    }
    catch (InvalidOperationException ex)
    {
        // Логировать ошибку спецификации
        Console.Error.WriteLine($"Ошибка: {ex.Message}");
        // Возвращать фильтр по умолчанию или выбросить дальше
        throw;
    }
    catch (ArgumentOutOfRangeException ex)
    {
        // Логировать ошибку параметра
        Console.Error.WriteLine($"Неверный параметр {ex.ParamName}: {ex.Message}");
        throw;
    }
}
```

---

## Сравнение с другими фильтрами

| Фильтр | АЧХ | Переходная | Порядок | Линейность фазы | Цель |
|--------|-----|-----------|--------|-----------------|------|
| **Butterworth** | Плоская | Хорошая | Средний | Хорошая | Универсальный выбор |
| Bessel | Очень плоская | Лучшая | Высокий | Отличная | Минимальное искажение |
| Chebyshev I | Волны (pass) | Средняя | Низкий | Средняя | Максимальная крутизна |
| Chebyshev II | Волны (stop) | Средняя | Низкий | Средняя | Крутизна + гладкость |
| Elliptic | Волны (обе) | Плохая | Минимальный | Плохая | Минимальный порядок |

**Butterworth рекомендуется для большинства приложений**, так как обеспечивает хороший баланс между всеми характеристиками.

---

## Интеграция с MathCore

### Зависимые компоненты

```
ButterworthLowPass
    ├─ MathCore.Polynom.Array (GetCoefficientsInverted, BinomialCoefficient)
    ├─ MathCore.SpecialFunctions (Pow, Tan, Atan, Log, Ceiling)
    └─ MathCore.Complex (Complex numbers и операции)
```

### Типичное использование в проекте

```csharp
using MathCore.DSP.Filters;
using MathCore.DSP.Signals;

public class SensorDataProcessor
{
    private readonly ButterworthLowPass _filter;
    
    public SensorDataProcessor(double samplingRate, double cutoffFreq)
    {
        double dt = 1.0 / samplingRate;
        _filter = new ButterworthLowPass(
            dt: dt,
            fp: cutoffFreq * 0.8,      // 80% от частоты среза
            fs: cutoffFreq * 1.2       // 120% от частоты среза
        );
    }
    
    public double[] ProcessMeasurements(double[] rawData)
    {
        return rawData.Select(_filter.Process).ToArray();
    }
    
    public void Reset()
    {
        _filter.Reset();
    }
}
```

---

## Ссылки и ресурсы

### Документация проекта

- 📚 **DSPlib**: https://ru.dsplib.org/content/filter_butter_ap/filter_butter_ap.html
- 📖 **MathCore**: https://github.com/infarh/MathCore

### Теория

- 🔗 [Википедия: Фильтр Баттерворта](https://en.wikipedia.org/wiki/Butterworth_filter)
- 🔗 [Википедия: Проектирование цифровых фильтров](https://en.wikipedia.org/wiki/Digital_filter)
- 🔗 [Билинейное преобразование](https://en.wikipedia.org/wiki/Bilinear_transform)

### Примеры и учебные материалы

- 📄 Примеры в коде проекта: `Tests/MathCore.DSP.Tests/Filters/ButterworthLowPass.cs`
- 📄 Применение: примеры в документации

---

## История версий

| Версия | Дата | Описание |
|--------|------|---------|
| 1.0 | 2024-01-01 | Исходная реализация фильтра Баттерворта |
| 1.1 | 2024-01-20 | Добавлена полная XML-документация всех методов |
| 1.2 | 2024-01-25 | Расширенная архитектурная документация и примеры |

---

## Автор и лицензия

**Компонент**: MathCore.DSP  
**Часть проекта**: MathCore  
**Лицензия**: Определяется основным проектом MathCore  
**Документация подготовлена**: GitHub Copilot (2024)

---

**Последнее обновление**: 2024-01-25  
**Статус документации**: ✅ Завершено и протестировано
